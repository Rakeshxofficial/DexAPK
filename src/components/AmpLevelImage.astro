---
// AMP-level optimized image component with LQIP, blurhash, and responsive loading
export interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  class?: string;
  sizes?: string;
  loading?: 'lazy' | 'eager';
  decoding?: 'async' | 'sync' | 'auto';
  fetchpriority?: 'high' | 'low' | 'auto';
  lqip?: boolean; // Low Quality Image Placeholder
  blurhash?: boolean; // BlurHash placeholder
}

const {
  src,
  alt,
  width,
  height,
  class: className = '',
  sizes = '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw',
  loading = 'lazy',
  decoding = 'async',
  fetchpriority = 'auto',
  lqip = true,
  blurhash = false,
  ...rest
} = Astro.props;

// Function to check if a URL is an external image
function isExternalImage(url: string): boolean {
  if (!url) return false;
  return url.startsWith('http') && !url.includes('dexapk.com');
}

// Generate image dimensions for proper aspect ratio
const aspectRatio = width && height ? width / height : undefined;

// Generate a unique ID for this image
const imageId = `img-${Math.random().toString(36).substring(2, 9)}`;

// For LQIP, we'll use a tiny version of the image
// Note: In a real implementation, you'd generate this server-side
const lqipUrl = src;

// For blurhash, we'd normally compute this server-side
// This is a placeholder blurhash for demonstration
const placeholderBlurhash = "L6PZfSi_.AyE_3t7t7R**0o#DgR4";

// Calculate dominant color (in a real implementation, this would be done server-side)
const dominantColor = "#e1e1e1";
---

<div class="amp-image-container" style={`background-color: ${dominantColor}; position: relative; overflow: hidden; ${aspectRatio ? `aspect-ratio: ${aspectRatio};` : ''}`}>
  {lqip && (
    <div class="lqip-placeholder" style="position: absolute; inset: 0; filter: blur(20px); transform: scale(1.1); opacity: 0.8; background-size: cover; background-position: center; transition: opacity 0.5s ease-out;" data-src={lqipUrl}></div>
  )}
  
  {blurhash && (
    <div class="blurhash-placeholder" style="position: absolute; inset: 0;" data-blurhash={placeholderBlurhash}></div>
  )}
  
  <img 
    id={imageId}
    src={src}
    alt={alt}
    class={`lazyload ${className}`}
    loading={loading}
    fetchpriority={fetchpriority}
    width={width}
    height={height}
    sizes={sizes}
    decoding={decoding}
    style="display: block; width: 100%; height: auto; opacity: 0; transition: opacity 0.5s ease-out;"
    data-src={src}
    {...rest}
  />
  
  {/* Noscript fallback for non-JS environments */}
  <noscript>
    <img 
      src={src}
      alt={alt}
      class={className}
      width={width}
      height={height}
      style="display: block; width: 100%; height: auto;"
    />
  </noscript>
</div>

<!-- Preload critical images -->
{fetchpriority === 'high' && (
  <link rel="preload" as="image" href={src} />
)}

<script define:vars={{ imageId, lqip }}>
// Initialize the LQIP placeholder
if (lqip) {
  const container = document.getElementById(imageId)?.closest('.amp-image-container');
  const placeholder = container?.querySelector('.lqip-placeholder');
  if (placeholder) {
    const lqipSrc = placeholder.getAttribute('data-src');
    if (lqipSrc) {
      placeholder.style.backgroundImage = `url(${lqipSrc})`;
    }
  }
}

// Set up intersection observer for the actual image
const img = document.getElementById(imageId);
if (img) {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const image = entry.target;
        
        // Load the actual image
        image.onload = () => {
          // Fade in the image
          image.style.opacity = '1';
          
          // Fade out the placeholder
          const container = image.closest('.amp-image-container');
          const placeholder = container?.querySelector('.lqip-placeholder, .blurhash-placeholder');
          if (placeholder) {
            placeholder.style.opacity = '0';
            
            // Remove placeholder after transition
            setTimeout(() => {
              placeholder.remove();
            }, 500);
          }
        };
        
        // Set the source to load the image
        if (image.getAttribute('data-src')) {
          image.src = image.getAttribute('data-src');
        }
        
        // Stop observing once loaded
        observer.unobserve(image);
      }
    });
  }, {
    rootMargin: '200px 0px', // Start loading 200px before it comes into view
    threshold: 0.01
  });
  
  observer.observe(img);
}
</script>

<style>
/* Ensure the container has proper sizing */
.amp-image-container {
  display: block;
  width: 100%;
  background-color: #f1f1f1; /* Default placeholder color */
  overflow: hidden;
}

/* Fade-in animation for images */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Reduce motion for users who prefer it */
@media (prefers-reduced-motion: reduce) {
  .amp-image-container img,
  .lqip-placeholder,
  .blurhash-placeholder {
    transition: none !important;
    animation: none !important;
  }
}
</style>