---
// Optimized Image Component with responsive srcset, lazy loading, and proper alt text
export interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  class?: string;
  sizes?: string;
  loading?: 'lazy' | 'eager' | 'auto';
  decoding?: 'async' | 'sync' | 'auto';
  fetchpriority?: 'high' | 'low' | 'auto';
  addStructuredData?: boolean;
  placeholder?: 'blur' | 'dominant-color' | 'none';
  quality?: number;
  isOffScreen?: boolean;
}

const {
  src,
  alt,
  width,
  height,
  class: className = '',
  sizes = '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw',
  loading = 'auto',
  decoding = 'async',
  fetchpriority = 'auto',
  addStructuredData = false,
  placeholder = 'blur',
  quality = 80,
  isOffScreen = false,
  ...rest
} = Astro.props;

// Function to check if a URL is an external image
function isExternalImage(url: string): boolean {
  if (!url) return false;
  return url.startsWith('http') && !url.includes('dexapk.com');
}

// Generate image dimensions for proper aspect ratio
const aspectRatio = width && height ? width / height : undefined;

// Determine if this is a stock photo from Pexels
const isPexels = src.includes('pexels.com');

// Generate blurhash placeholder
const generatePlaceholder = (src: string) => {
  // For production, you would pre-compute these values
  // This is a lightweight placeholder for demo purposes
  return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 ${width || 800} ${height || 600}'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' fill='%23f0f0f0'/%3E%3C/svg%3E`;
};

// Get placeholder based on strategy
const placeholderUrl = placeholder !== 'none' ? generatePlaceholder(src) : '';

// Format quality parameter for CDN
const qualityParam = src.includes('?') ? `&q=${quality}` : `?q=${quality}`;

// Add auto format parameter for CDN
const formatParam = src.includes('?') ? '&auto=format' : '?auto=format';

// Prepare optimized URL
const optimizedSrc = isExternalImage(src) ? src : `${src}${qualityParam}`;

// Determine loading strategy based on whether image is off-screen
const finalLoading = isOffScreen ? 'lazy' : loading === 'auto' ? 
  (fetchpriority === 'high' ? 'eager' : 'lazy') : loading;

// Determine fetchpriority based on loading and off-screen status
const finalFetchpriority = isOffScreen ? 'low' : fetchpriority;
---

<!-- Image with proper attributes -->
<img 
  src={optimizedSrc}
  alt={alt}
  class={`${className || ''}`}
  loading={finalLoading}
  fetchpriority={finalFetchpriority}
  width={width}
  height={height}
  sizes={sizes}
  decoding={decoding}
  {...rest}
/>
<!-- Preload critical images -->
{fetchpriority === 'high' && (
  <link rel="preload" as="image" href={optimizedSrc} />
)}

<!-- Add structured data for images -->
{addStructuredData && (
  <script type="application/ld+json" set:html={JSON.stringify({
    "@context": "https://schema.org",
    "@type": "ImageObject",
    "url": optimizedSrc,
    "name": alt,
    "width": width,
    "height": height,
    "encodingFormat": src.endsWith('.webp') ? "image/webp" : 
                      src.endsWith('.jpg') || src.endsWith('.jpeg') ? "image/jpeg" : 
                      src.endsWith('.png') ? "image/png" : "image/webp"
  })} />
)}