---
// Optimized Image Component with responsive srcset, lazy loading, and proper alt text
export interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  class?: string;
  sizes?: string; 
  loading?: 'lazy' | 'eager';
  decoding?: 'async' | 'sync' | 'auto';
  fetchpriority?: 'high' | 'low' | 'auto';
  placeholder?: boolean;
  blurhash?: string;
  addStructuredData?: boolean;
}

const {
  src,
  alt,
  width,
  height,
  class: className = '',
  sizes = '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw',
  loading = 'lazy',
  decoding = 'async',
  fetchpriority = 'auto',
  placeholder = true,
  blurhash,
  addStructuredData = false,
  ...rest
} = Astro.props;

// Function to check if a URL is an external image
function isExternalImage(url: string): boolean {
  if (!url) return false;
  return url.startsWith('http') && !url.includes('dexapk.com');
}

// Calculate aspect ratio for proper sizing
const aspectRatio = width && height ? (width / height).toFixed(2) : undefined;
const paddingBottom = aspectRatio ? `${(1 / Number(aspectRatio) * 100).toFixed(2)}%` : undefined;

// Determine if this is a stock photo from Pexels
const isPexels = src.includes('pexels.com');

// Generate a simple placeholder color based on the image URL
const placeholderColor = src ? 
  `#${src.split('').reduce((acc, char) => (acc * char.charCodeAt(0)) % 0xffffff, 0x123456).toString(16).padStart(6, '0')}` : 
  '#f0f0f0';

// Determine if WebP is supported
const isWebP = src.endsWith('.webp') || src.endsWith('.WEBP');

// Get file extension
const fileExtension = src.split('.').pop()?.toLowerCase() || 'jpg';

// Create optimized image URL (without modifying the original URL)
const imageUrl = src;
---

<!-- Image with proper attributes -->
<img 
  src={src}
  alt={alt}
  class={`image-optimized ${className || ''}`} 
  loading={loading}
  fetchpriority={fetchpriority}
  width={width}
  height={height}
  sizes={sizes}
  decoding={decoding}
  style={aspectRatio ? `aspect-ratio: ${aspectRatio};` : undefined}
  {...rest}
/>

{placeholder && !blurhash && (
  <div 
    class="image-placeholder" 
    style={`background-color: ${placeholderColor}; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; ${paddingBottom ? `padding-bottom: ${paddingBottom};` : ''}`}
    aria-hidden="true"
  ></div>
)}

{placeholder && blurhash && (
  <div 
    class="image-blurhash" 
    data-blurhash={blurhash}
    style={`position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; ${paddingBottom ? `padding-bottom: ${paddingBottom};` : ''}`}
    aria-hidden="true"
  ></div>
)}

<!-- Preload critical images -->
{fetchpriority === 'high' && (
  <link rel="preload" as="image" href={src} />
)}

<!-- Add structured data for images -->
{addStructuredData && (
  <script type="application/ld+json" set:html={JSON.stringify({
    "@context": "https://schema.org",
    "@type": "ImageObject",
    "url": src,
    "name": alt,
    "width": width,
    "height": height,
    "encodingFormat": src.endsWith('.webp') ? "image/webp" : 
                      src.endsWith('.jpg') || src.endsWith('.jpeg') ? "image/jpeg" : 
                      src.endsWith('.png') ? "image/png" : "image/webp"
  })} />
)}

<style>
.image-optimized {
  max-width: 100%;
  height: auto;
  transition: opacity 0.3s ease;
  will-change: opacity;
  transform: translateZ(0);
  backface-visibility: hidden;
}

.image-optimized[loading="lazy"] {
  opacity: 0;
  animation: fadeIn 0.3s ease forwards;
}

.image-placeholder,
.image-blurhash {
  background-size: cover;
  background-position: center;
  transition: opacity 0.3s ease;
}

.image-optimized.loaded + .image-placeholder,
.image-optimized.loaded + .image-blurhash {
  opacity: 0;
}

@keyframes fadeIn {
  to {
    opacity: 1;
  }
}

/* Reduce motion for users who prefer it */
@media (prefers-reduced-motion: reduce) {
  .image-optimized {
    animation: none;
    transition: none;
  }
  
  .image-placeholder,
  .image-blurhash {
    transition: none;
  }
}
</style>

<script>
// Enhanced lazy loading with intersection observer
document.addEventListener('DOMContentLoaded', () => {
  const images = document.querySelectorAll('.image-optimized[loading="lazy"]');
  
  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        
        // Handle image load
        const handleLoad = () => {
          img.classList.add('loaded');
          img.style.opacity = '1';
          
          // Track image load for analytics
          if (window.performance && window.performance.mark) {
            window.performance.mark(`img-loaded-${img.src}`);
          }
        };
        
        // If image is already loaded
        if (img.complete) {
          handleLoad();
        } else {
          // Add load event listener
          img.addEventListener('load', handleLoad);
        }
        
        imageObserver.unobserve(img);
      }
    });
  }, { threshold: 0.1 });
  
  images.forEach(img => imageObserver.observe(img));
  
  // Initialize blurhash placeholders if the library is available
  const blurhashElements = document.querySelectorAll('.image-blurhash[data-blurhash]');
  if (blurhashElements.length > 0 && typeof window.blurhash !== 'undefined') {
    blurhashElements.forEach(element => {
      const blurhash = element.getAttribute('data-blurhash');
      if (blurhash) {
        // This would use the blurhash library if available
        // window.blurhash.getDataURL(blurhash, 32, 32, (dataURL) => {
        //   element.style.backgroundImage = `url(${dataURL})`;
        // });
      }
    });
  }
});
</script>