---
// Markdown renderer component with automatic Table of Contents generation
interface Props {
  content: string;
  generateToc?: boolean;
}

const { content, generateToc = true } = Astro.props;

// Simple markdown parser for headings and basic formatting
function parseMarkdown(markdown: string) {
  if (!markdown) return { html: '', toc: [] };
  
  const lines = markdown.split('\n');
  const toc = [];
  let html = '';
  let inCodeBlock = false;
  let inList = false;
  let listType = '';
  let inTable = false;
  
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    
    // Handle code blocks
    if (line.startsWith('```')) {
      inCodeBlock = !inCodeBlock;
      if (inCodeBlock) {
        const language = line.slice(3).trim();
        html += `<pre class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 overflow-x-auto my-4"><code class="language-${language}">`;
      } else {
        html += '</code></pre>';
      }
      continue;
    }
    
    if (inCodeBlock) {
      html += escapeHtml(line) + '\n';
      continue;
    }
    
    // Handle headings
    const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      const text = headingMatch[2];
      const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
      
      if (generateToc) {
        toc.push({ level, text, id });
      }
      
      html += `<h${level} id="${id}" class="text-${level === 1 ? '3xl' : level === 2 ? '2xl' : level === 3 ? 'xl' : 'lg'} font-bold text-gray-900 dark:text-white mb-4 mt-8">${text}</h${level}>`;
      continue;
    }
    
    // Handle horizontal rules
    if (line.match(/^---+$/)) {
      html += '<hr class="border-gray-200 dark:border-gray-700 my-8">';
      continue;
    }
    
    // Handle lists
    const listMatch = line.match(/^(\s*)([-*+]|\d+\.)\s+(.+)$/);
    if (listMatch) {
      const indent = listMatch[1].length;
      const marker = listMatch[2];
      const text = listMatch[3];
      const isOrdered = /^\d+\./.test(marker);
      
      if (!inList) {
        inList = true;
        listType = isOrdered ? 'ol' : 'ul';
        html += `<${listType} class="${listType === 'ol' ? 'list-decimal' : 'list-disc'} list-inside space-y-2 my-4 text-gray-700 dark:text-gray-300">`;
      }
      
      html += `<li class="ml-${Math.floor(indent / 2) * 4}">${formatInlineMarkdown(text)}</li>`;
      continue;
    } else if (inList) {
      inList = false;
      html += `</${listType}>`;
    }
    
    // Handle blockquotes
    if (line.startsWith('> ')) {
      html += `<blockquote class="border-l-4 border-blue-500 pl-4 italic text-gray-600 dark:text-gray-400 my-4">${formatInlineMarkdown(line.slice(2))}</blockquote>`;
      continue;
    }
    
    // Handle tables
    if (line.includes('|')) {
      const cells = line.split('|').map(cell => cell.trim()).filter(Boolean);
      
      // Skip empty table rows
      if (cells.length === 0) {
        continue;
      }
      
      if (cells.length >= 1) {
        // Check if next line is table separator
        const nextLine = lines[i + 1];
        
        if (!inTable && nextLine && nextLine.includes('|') && nextLine.includes('---')) {
          // Table header
          inTable = true;
          html += '<div class="overflow-x-auto my-6"><table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700"><thead class="bg-gray-50 dark:bg-gray-800"><tr>';
          cells.forEach(cell => {
            html += `<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">${formatInlineMarkdown(cell)}</th>`;
          });
          html += '</tr></thead><tbody class="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">';
          i++; // Skip separator line
          continue;
        } else if (inTable) {
          // Table row within an existing table
          html += '<tr>';
          cells.forEach(cell => {
            html += `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${formatInlineMarkdown(cell)}</td>`;
          });
          html += '</tr>';
          continue;
        } else if (!inTable) {
          // This is a standalone table (not preceded by a separator line)
          inTable = true;
          html += '<div class="overflow-x-auto my-6"><table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700"><tbody class="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">';
          html += '<tr>';
          cells.forEach(cell => {
            html += `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${formatInlineMarkdown(cell)}</td>`;
          });
          html += '</tr>';
          continue;
        }
      }
    }
    
    // If we're not in a table row but were in a table, close the table
    if (inTable && !line.includes('|')) {
      html += '</tbody></table></div>';
      inTable = false;
    }
    
    // Handle paragraphs
    if (line.trim()) {
      html += `<p class="text-gray-700 dark:text-gray-300 leading-relaxed mb-4">${formatInlineMarkdown(line)}</p>`;
    } else {
      html += '<br>';
    }
  }
  
  // Close any open lists
  if (inList) {
    html += `</${listType}>`;
  }
  
  // Close any open tables
  if (inTable) {
    html += '</tbody></table></div>';
  }
  
  return { html, toc };
}

function formatInlineMarkdown(text: string): string {
  return text
    // Bold
    .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold">$1</strong>')
    // Italic
    .replace(/\*(.*?)\*/g, '<em class="italic">$1</em>')
    // Code
    .replace(/`(.*?)`/g, '<code class="bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded text-sm font-mono">$1</code>')
    // Links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-blue-600 dark:text-blue-400 hover:underline" target="_blank" rel="noopener noreferrer">$1</a>')
    // Strikethrough
    .replace(/~~(.*?)~~/g, '<del class="line-through">$1</del>');
}

function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

const { html, toc } = parseMarkdown(content);
---

{generateToc && toc.length > 0 && (
  <div class="bg-white dark:bg-gray-800 rounded-2xl border border-gray-200 dark:border-gray-700 overflow-hidden mb-8">
    <div class="px-6 py-4 border-b border-gray-200 dark:border-gray-700">
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white flex items-center">
        <svg class="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"/>
        </svg>
        Table of Contents
      </h3>
    </div>
    <div class="px-6 py-4">
      <nav class="space-y-2">
        {toc.map(item => (
          <a 
            href={`#${item.id}`}
            class={`block text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 transition-colors duration-200 ${
              item.level === 1 ? 'font-semibold' : 
              item.level === 2 ? 'ml-4' : 
              item.level === 3 ? 'ml-8' : 
              'ml-12'
            }`}
          >
            {item.text}
          </a>
        ))}
      </nav>
    </div>
  </div>
)}

<div class="prose prose-gray dark:prose-invert max-w-none">
  <div set:html={html} />
</div>

<style>
  /* Enhanced prose styles */
  .prose {
    line-height: 1.6;
  }
  
  .prose h1, .prose h2, .prose h3, .prose h4, .prose h5, .prose h6 {
    scroll-margin-top: 2rem;
  }
  
  /* Increase scroll margin to prevent headings from being hidden under the header */
  .prose h1, .prose h2, .prose h3 {
    scroll-margin-top: 8rem;
  }
  
  /* Add scroll margin to heading IDs for TOC links */
  h1[id], h2[id], h3[id], h4[id], h5[id], h6[id] {
    scroll-margin-top: 8rem;
  }
  
  .prose pre {
    background: #f8f9fa;
    border: 1px solid #e9ecef;
  }
  
  .dark .prose pre {
    background: #1f2937;
    border: 1px solid #374151;
  }
  
  .prose table {
    border-collapse: collapse;
    margin: 1.5rem 0;
  }
  
  .prose th, .prose td {
    border: 1px solid #e5e7eb;
  }
  
  .dark .prose th, .dark .prose td {
    border-color: #374151;
  }
  
  /* Smooth scrolling for anchor links */
  @media (prefers-reduced-motion: no-preference) {
    html {
      scroll-behavior: smooth;
    }
  }
</style>

<script>
  // Add click handlers for table of contents
  document.addEventListener('DOMContentLoaded', () => {
    const tocLinks = document.querySelectorAll('nav a[href^="#"]');
    
    tocLinks.forEach(link => {
      link.addEventListener('click', e => {
        e.preventDefault();
        const targetId = e.currentTarget.getAttribute('href').slice(1);
        const targetElement = document.getElementById(targetId);
        
        if (targetElement) {
          // Get the header height to offset the scroll position
          const headerHeight = document.querySelector('header')?.offsetHeight || 100;
          
          // Use requestAnimationFrame to avoid forced reflow
          window.requestAnimationFrame(() => {
            const targetPosition = targetElement.getBoundingClientRect().top + window.scrollY;
            const scrollOffset = headerHeight + 40; // Add extra padding
            
            // Scroll to element with offset for the header
            window.scrollTo({
              top: targetPosition - scrollOffset,
              behavior: 'smooth'
            });
            
            // Update URL without triggering page reload
            history.pushState(null, null, `#${targetId}`);
            
            // Announce to screen readers
            announceToScreenReader(`Navigated to ${targetId.replace(/-/g, ' ')} section`);
          });
        }
      }, { passive: false });
    });
    
    // Function for screen reader announcements
    function announceToScreenReader(message) {
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'polite');
      announcement.setAttribute('aria-atomic', 'true');
      announcement.className = 'sr-only';
      announcement.textContent = message;
      
      document.body.appendChild(announcement);
      
      setTimeout(() => {
        document.body.removeChild(announcement);
      }, 1000);
    }
  });
</script>